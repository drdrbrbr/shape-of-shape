---
import Page from "@/layouts/Page.astro";
//microCMS呼び出し
import { getArticles } from "../library/microcms";
const response = await getArticles({ fields: ["id", "title"] });
---

<Page title="TOP" pageClass="index">
  <div class="kv">
    <div id="p5-canvas"></div>
    <h1>
      <div>
        <span>S</span><span>H</span><span>A</span><span>P</span><span>E</span>
      </div>
      <div><span>O</span><span>F</span></div>
      <div>
        <span>S</span><span>H</span><span>A</span><span>P</span><span>E</span>
      </div>
    </h1>
    <p class="jp_title">かたち の かたち</p>
  </div>
  <div class="wrap">
    <ul>
      {
        response.contents.map((content: any, index: number) => (
          <li>
            <a href={`/${content.id}`}>
              <span class="index">{`(${content.id})`}</span>
              <span
                class="title"
                set:html={content.title.replace(/\n/g, "<br>")}
              />
            </a>
          </li>
        ))
      }
    </ul>
  </div>
</Page>

<style lang="scss">
  .kv {
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;

    #p5-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
    }

    h1 {
      font-weight: 200;
      font-style: italic;
      font-size: 20vh;
      width: 90%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      height: 90vh;
      position: relative;
      z-index: 2;
      div {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }

      span {
        display: block;
        line-height: 100%;
        transition: transform 0.2s var(--ease-quint-out);
      }
    }
    .jp_title {
      font-size: get_pc_vw(12);
      font-weight: 500;
      line-height: 100%;
      letter-spacing: 0.28em;
      position: absolute;
      top: 50%;
      right: 25%;
      transform: translateY(-50%);
    }
  }
  .wrap {
    padding: 0 get_pc_vw(8);
    ul {
      display: flex;
      flex-wrap: wrap;
      gap: get_pc_vw(66);
      li {
        font-size: get_pc_vw(12);
        position: relative;
        a {
          width: get_pc_vw(170);
          height: get_pc_vw(170);
          display: block;
          padding: get_pc_vw(8) 0 0 get_pc_vw(8);
          &:hover {
            background-color: var(--key-color);
            color: #fff;
          }
          .index {
            font-weight: 600;
            line-height: 100%;
            letter-spacing: 0.02em;
          }
          .title {
            display: block;
            margin-top: get_pc_vw(10);
          }
        }
      }
    }
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const spans = document.querySelectorAll(".kv span");

    spans.forEach((span) => {
      // 0, 90, 180, 270度の中からランダムに選択
      const rotations = [0, 90, 180, 270];
      const randomRotation =
        rotations[Math.floor(Math.random() * rotations.length)];

      (span as HTMLElement).style.transform = `rotate(${randomRotation}deg)`;
    });

    // p5.jsでランダムな形を描画
    const script = document.createElement("script");
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js";
    script.onload = function () {
      new p5((p) => {
        p.setup = function () {
          const canvas = p.createCanvas(400, 400);
          canvas.parent("p5-canvas");
          // 最初の形を生成
          targetShape = p.generateNewShape();
          // noLoop()を削除してアニメーションを有効化
        };

        let lastTime = 0;
        const interval = 2000; // 2秒間隔
        let currentShape = null;
        let targetShape = null;
        let morphProgress = 0;
        const morphSpeed = 0.05; // モーフィング速度

        p.draw = function () {
          // 完全にクリア
          p.clear();
          p.background(0, 0, 0, 0);

          // 2秒ごとに新しい形を生成
          if (p.millis() - lastTime >= interval) {
            lastTime = p.millis();
            currentShape = targetShape; // 現在の形を保存
            targetShape = p.generateNewShape(); // 新しい目標形を生成
            morphProgress = 0; // モーフィングをリセット
          }

          // モーフィング中または初期化
          if (targetShape) {
            if (!currentShape) {
              currentShape = targetShape;
            }

            // モーフィング進行
            morphProgress += morphSpeed;
            if (morphProgress > 1) morphProgress = 1;

            // イージングを適用
            const easedProgress = p.easeInOutCubic(morphProgress);

            // 現在の形と目標形の間を補間
            const morphedShape = p.morphShapes(
              currentShape,
              targetShape,
              easedProgress
            );
            p.drawMorphedShape(morphedShape);
          } else {
            // 初期化時に最初の形を描画
            if (!targetShape) {
              targetShape = p.generateNewShape();
              currentShape = targetShape;
            }
          }
        };

        // 新しい形を生成する関数
        p.generateNewShape = function () {
          const centerX = p.width / 2;
          const centerY = p.height / 2;
          const size = p.random(150, 180);
          const numShapes = p.floor(p.random(1, 6));

          const shapes = [];
          for (let i = 0; i < numShapes; i++) {
            const shape = {
              x: centerX + p.random(-size / 6, size / 6),
              y: centerY + p.random(-size / 6, size / 6),
              rotation: p.random(p.TWO_PI),
              size: p.random(size * 0.9, size * 0.9),
              vertices: p.generateVertices(
                p.random(3, 8),
                p.random(size * 0.9, size * 0.9)
              ),
            };
            shapes.push(shape);
          }
          return shapes;
        };

        // 頂点を生成する関数（順序を保持）
        p.generateVertices = function (numVertices, size) {
          const vertices = [];

          // 基準となる角度を生成（時計回り）
          const baseAngles = [];
          for (let i = 0; i < numVertices; i++) {
            baseAngles.push((p.TWO_PI / numVertices) * i);
          }

          // 各頂点を順序を保って生成
          for (let i = 0; i < numVertices; i++) {
            const angle = baseAngles[i] + p.random(-0.2, 0.2); // 角度の変動を小さく
            const radius = size * p.random(0.6, 1.0); // 半径の変動を小さく
            const x =
              p.cos(angle) * radius + p.random(-size * 0.05, size * 0.05);
            const y =
              p.sin(angle) * radius + p.random(-size * 0.05, size * 0.05);
            vertices.push({ x, y });
          }

          return vertices;
        };

        // 形をモーフィングする関数
        p.morphShapes = function (currentShapes, targetShapes, progress) {
          const morphedShapes = [];
          const maxShapes = p.max(currentShapes.length, targetShapes.length);

          for (let i = 0; i < maxShapes; i++) {
            const current = currentShapes[i] || currentShapes[0];
            const target = targetShapes[i] || targetShapes[0];

            const morphedShape = {
              x: p.lerp(current.x, target.x, progress),
              y: p.lerp(current.y, target.y, progress),
              rotation: p.lerp(current.rotation, target.rotation, progress),
              size: p.lerp(current.size, target.size, progress),
              vertices: p.morphVertices(
                current.vertices,
                target.vertices,
                progress
              ),
            };
            morphedShapes.push(morphedShape);
          }
          return morphedShapes;
        };

        // 頂点をモーフィングする関数（ねじれ防止）
        p.morphVertices = function (currentVertices, targetVertices, progress) {
          const morphedVertices = [];

          // 頂点数を統一（少ない方に合わせる）
          const minVertices = p.min(
            currentVertices.length,
            targetVertices.length
          );

          for (let i = 0; i < minVertices; i++) {
            const current = currentVertices[i];
            const target = targetVertices[i];

            morphedVertices.push({
              x: p.lerp(current.x, target.x, progress),
              y: p.lerp(current.y, target.y, progress),
            });
          }

          // 余った頂点は最後の頂点に合わせる
          if (currentVertices.length > minVertices) {
            for (let i = minVertices; i < currentVertices.length; i++) {
              const current = currentVertices[i];
              const lastTarget = targetVertices[targetVertices.length - 1];

              morphedVertices.push({
                x: p.lerp(current.x, lastTarget.x, progress),
                y: p.lerp(current.y, lastTarget.y, progress),
              });
            }
          } else if (targetVertices.length > minVertices) {
            for (let i = minVertices; i < targetVertices.length; i++) {
              const lastCurrent = currentVertices[currentVertices.length - 1];
              const target = targetVertices[i];

              morphedVertices.push({
                x: p.lerp(lastCurrent.x, target.x, progress),
                y: p.lerp(lastCurrent.y, target.y, progress),
              });
            }
          }

          return morphedVertices;
        };

        // イージング関数
        p.easeInOutCubic = function (t) {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        };

        p.easeInOutQuad = function (t) {
          return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        };

        p.easeInOutSine = function (t) {
          return -(Math.cos(Math.PI * t) - 1) / 2;
        };

        // モーフィングされた形を描画する関数
        p.drawMorphedShape = function (shapes) {
          p.fill("#4C74B9");
          p.noStroke();

          for (let shape of shapes) {
            p.push();
            p.translate(shape.x, shape.y);
            p.rotate(shape.rotation);

            p.beginShape();
            const vertices = shape.vertices;

            // curveVertexを使用して滑らかな曲線を作成
            if (vertices.length > 0) {
              p.curveVertex(vertices[0].x, vertices[0].y);
              p.curveVertex(vertices[0].x, vertices[0].y);

              for (let vertex of vertices) {
                p.curveVertex(vertex.x, vertex.y);
              }

              p.curveVertex(
                vertices[vertices.length - 1].x,
                vertices[vertices.length - 1].y
              );
              p.curveVertex(
                vertices[vertices.length - 1].x,
                vertices[vertices.length - 1].y
              );
            }
            p.endShape(p.CLOSE);
            p.pop();
          }
        };
      });
    };
    document.head.appendChild(script);
  });
</script>
